#include <iostream>
#include <map>
#include "vector"
#include "string"

#define MAXLEN 10000
using namespace std;

struct state //струтктура данных, которая хранит всю информацию о конкретном переходе. Суффиксный автомат - массив состяний.
{
    int len; // длина перехода
    int link;// ссылка
    map <char,int> next; // список переходов
};
class DAWG
{
    private:
        state st[MAXLEN]; // массив состояний
        int sz = 0; //cчетчик состояний. Начальное состояние - это нулевое состояние;
        int last = 0; //это состояние, соответствующее всей текущей строке до добавления символа c.
        string s; // строка, по которой строим автомат
    public:
        DAWG(string s)
        {
            this->s = s;
            // Добалвяем начальное состояние в автомат
            st[0].len = 0;
            st[0].link = -1;
            ++sz;
        }
        void DAWG_extend(char c) // Функция для добавления нового символа в автомат
        {
            int cur = sz++; // Создаем новое состояние
            st[cur].len = st[last].len + 1;
            int p; // номер состояния на котором, мы обнаружим, что переход по символу с имеется
            /* Описание цикла:
             1.изначально мы стоим в состоянии last;
             2.если из него нет перехода по букве c, то добавляем этот переход по букве c в состояние cur,
             3.затем переходим по суффиксной ссылке, снова проверяя — если нет перехода, то добавляем
             4.Если в какой-то момент случится, что такой переход уже есть, то останавливаемся — и обозначим через p номер состояния, на котором это произошло.
             */
            for (p=last; p!=-1 && !st[p].next.count(c); p=st[p].link)
            {
                st[p].next[c] = cur;
            }
            if (p == -1) //  Ни разу не случилось, что имелся переход по букве с. Тогда суффиксная ссылка из этого состояния = 0;
                st[cur].link = 0;
            // Иначе: мы остановились на каком-то сотоянии, из которого уже был переход по букве с.
            else
            {
                int q = st[p].next[c]; // q - куда ведет имеющийся переход по букве с
                if (st[p].len + 1 == st[q].len) // Если состояние сплошное, то
                    st[cur].link = q; // ссылка текущего элемента = q
                 /*Если состояние не является сплошным - необходимо произвести "клонирование" состояния q:
                   создать новое состояние clone,копировав в него все данные из вершины q (суффиксную ссылку, переходы)
                   len надо присвоить len(clone) = len(p) + 1.
                  */
                else
                {
                    int clone = sz++;
                    st[clone].len = st[p].len + 1;
                    st[clone].next = st[q].next;
                    st[clone].link = st[q].link;
                    for (; p!=-1 && st[p].next[c]==q; p=st[p].link)
                        st[p].next[c] = clone;
                    st[q].link = clone; // Cуффиксная ссылка q проводится в clone
                    st[cur].link = clone;//После клонирования мы проводим суффиксную ссылку из cur в это состояние clone
                }
            }
            last = cur; //В любом случае, чем бы ни закончилось выполнение этой процедуры, мы в конце обновляем значение last, присваивая ему cur.

        }
        void getDAWG() // построение автомата по строке s;
        {
            for (int i=0; i < s.length(); ++i)
            {
                DAWG_extend (s[i]);
            }
        }
    bool DAWG_search (string t)
    {
        if(t.length()>s.length())
        {
            cout << "Строка t не может явяется подстрокой s";
            return false;
        }
        getDAWG(); // Построение суффиксного автомата
        int v = 0; // v - текущее состояние, изначально она равна начальному состоянию t_0
        for (int i = 0; i < t.length(); ++i)  // Идем по символам подстроки t
        {
            if (st[v].next.count(t[i])) // Делаем, если возможно переход из текущего состояния v в новое состояние
            {
                v = st[v].next[t[i]];
            }
            else // Если перехода нет из текущего, то подстрока не входит в t;
            {
              cout << "Строка t не является подстрокой s";
              return false;
            }
        }
        cout << "Строка t  является подстрокой s";
        return true;
    }
};
int main()
{
    string s, t;
    cout << "Введите проверяему строку s" << "\n";
    cin >> s;
    cout << "Введите проверяему подстроку t" << "\n";
    cin >> t;
    DAWG suffix_auto(s);
    suffix_auto.DAWG_search(t);
    return 0;
}
